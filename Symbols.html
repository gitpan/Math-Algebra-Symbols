<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Math::Algebra::Symbols - Symbolic Algebra using Perl</title>
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<ul>

		<li><a href="#symbols">Symbols</a></li>
		<ul>

			<li><a href="#constructor_routine_name">Constructor Routine Name</a></li>
			<li><a href="#constructing_expressions_with_big_integers">Constructing Expressions with Big Integers</a></li>
		</ul>

		<li><a href="#operators">Operators</a></li>
		<ul>

			<li><a href="#arithmetic_operators">Arithmetic operators</a></li>
			<ul>

				<li><a href="#arithmetic_operators:_+__*_/_**">Arithmetic Operators: <strong>+</strong> <strong>-</strong> <strong>*</strong> <strong>/</strong> <strong>**</strong> </a></li>
				<li><a href="#square_root_operator:_sqrt">Square root Operator: <strong>sqrt</strong></a></li>
				<li><a href="#exponential_operator:_exp">Exponential Operator: <strong>exp</strong></a></li>
				<li><a href="#logarithm_operator:_log">Logarithm Operator: <strong>log</strong></a></li>
				<li><a href="#sine_and_cosine_operators:_sin_and_cos">Sine and Cosine Operators: <strong>sin</strong> and <strong>cos</strong></a></li>
			</ul>

			<li><a href="#relational_operators">Relational operators</a></li>
			<ul>

				<li><a href="#relational_operators:_==,_!=">Relational operators: <strong>==</strong>, <strong>!=</strong></a></li>
				<li><a href="#relational_operator:_eq">Relational operator: <strong>eq</strong></a></li>
			</ul>

			<li><a href="#implication_operators">Implication operators</a></li>
			<ul>

				<li><a href="#solve_operator:_>">Solve operator: <strong>&gt;</strong></a></li>
			</ul>

			<li><a href="#complex_operators">Complex operators</a></li>
			<ul>

				<li><a href="#complex_operators:_the_dot_operator:_^">Complex operators: the <strong>dot</strong> operator: <strong>^</strong></a></li>
				<li><a href="#complex_operators:_the_cross_operator:_x">Complex operators: the <strong>cross</strong> operator: <strong>x</strong></a></li>
				<li><a href="#complex_operators:_the_conjugate_operator:_~">Complex operators: the <strong>conjugate</strong> operator: <strong>~</strong></a></li>
				<li><a href="#complex_operators:_the_modulus_operator:_abs">Complex operators: the <strong>modulus</strong> operator: <strong>abs</strong></a></li>
				<li><a href="#complex_operators:_the_unit_operator:_!">Complex operators: the <strong>unit</strong> operator: <strong>!</strong></a></li>
			</ul>

		</ul>

		<li><a href="#functions">Functions</a></li>
		<ul>

			<li><a href="#trigonometric_and_hyperbolic_functions">Trigonometric and Hyperbolic functions</a></li>
			<ul>

				<li><a href="#trigonometric_functions">Trigonometric functions</a></li>
				<li><a href="#hyperbolic_functions">Hyperbolic functions</a></li>
			</ul>

			<li><a href="#complex_functions">Complex functions</a></li>
			<ul>

				<li><a href="#complex_functions:_re_and_im">Complex functions: <strong>re</strong> and <strong>im</strong></a></li>
				<li><a href="#complex_functions:_dot_and_cross">Complex functions: <strong>dot</strong> and <strong>cross</strong></a></li>
				<li><a href="#complex_functions:_conjugate,_modulus_and_unit">Complex functions: <strong>conjugate</strong>, <strong>modulus</strong> and <strong>unit</strong></a></li>
			</ul>

		</ul>

		<li><a href="#methods">Methods</a></li>
		<ul>

			<li><a href="#methods_for_manipulating_equations">Methods for manipulating Equations</a></li>
			<ul>

				<li><a href="#simplifying_equations:_sub()">Simplifying equations: <strong>sub()</strong></a></li>
				<li><a href="#solving_equations:_solve()">Solving equations: <strong>solve()</strong></a></li>
			</ul>

			<li><a href="#methods_for_performing_calculus">Methods for performing Calculus</a></li>
			<ul>

				<li><a href="#differentiation:_d()">Differentiation: <strong>d()</strong></a></li>
			</ul>

		</ul>

		<li><a href="#examples">Examples</a></li>
		<ul>

			<li><a href="#example_expressions">Example Expressions</a></li>
			<li><a href="#example_of_equation_solving:_the_focii_of_a_hyperbola:">Example of Equation Solving: the focii of a hyperbola:</a></li>
			<li><a href="#further_examples">Further Examples</a></li>
		</ul>

	</ul>

	<li><a href="#export">EXPORT</a></li>
	<li><a href="#packages">PACKAGES</a></li>
	<ul>

		<li><a href="#math::algebra::symbolsterm">Math::Algebra::SymbolsTerm</a></li>
		<li><a href="#math::algebra::symbolssum">Math::Algebra::SymbolsSum</a></li>
		<li><a href="#math::algebra::symbols">Math::Algebra::Symbols</a></li>
	</ul>

	<li><a href="#author">AUTHOR</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>Math::Algebra::Symbols - Symbolic Algebra using Perl</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
 use Math::Algebra::Symbols hyper=&gt;1;</pre>
<pre>
 ($n, $x, $y) = symbols(qw(n x y));</pre>
<pre>
  $a     = sin($x)**2 + cos($x)**2; 
  $b     = (sin($n*$x)+cos($n*$x))-&gt;d-&gt;d-&gt;d-&gt;d/(sin($n*$x)+cos($n*$x)) == $n**4;
  $c     = tanh($x+$y) == (tanh($x)+tanh($y))/(1+tanh($x)*tanh($y));
 ($d,$e) = @{($x**2-5*$x+6) &gt; $x};</pre>
<pre>
 print &quot;$a\n$b\n$c\n$d,$e\n&quot;;</pre>
<pre>
 # 1                                        
 # 1
 # 1                                   
 # 2,3</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>This package supplies a set of functions and operators to manipulate
operator expressions algebraically  using the familiar Perl syntax.</p>
<p>These expressions are constructed
from <a href="#symbols">Symbols</a>, <a href="#operators">Operators</a>, and <a href="#functions">Functions</a>, and processed via
<a href="#methods">Methods</a>.  For examples, see: <a href="#examples">Examples</a>.</p>
<p>
</p>
<h2><a name="symbols">Symbols</a></h2>
<p>Symbols are created with the exported <strong>symbols()</strong> constructor routine:</p>
<pre>
 use Math::Algebra::Symbols;</pre>
<pre>
 my ($x, $y, $i, $o, $pi) = symbols(qw(x y i 1 pi));</pre>
<pre>
 print &quot;$x $y $i $o\n&quot;;</pre>
<pre>
 # $x $y $i 1</pre>
<p>The <strong>symbols()</strong> routine constructs references to symbolic variables and
symbolic constants from a list of names and integer constants.</p>
<p>The special symbol <strong>i</strong> is recognized as the square root of <strong>-1</strong>.</p>
<p>The special symbol <strong>pi</strong> is recognized as the smallest positive real
that satisfies:</p>
<pre>
 use Math::Algebra::Symbols;</pre>
<pre>
 ($i, $pi) = symbols(qw(i pi));</pre>
<pre>
 print exp($i*$pi), &quot;\n&quot;;</pre>
<pre>
 # -1</pre>
<p>
</p>
<h3><a name="constructor_routine_name">Constructor Routine Name</a></h3>
<p>If you wish to use a different name for the constructor routine, say
<strong>S</strong>:</p>
<pre>
 use Math::Algebra::Symbols symbols=&gt;'S';</pre>
<pre>
 my ($x, $y, $i, $o) = S(qw(x y i 1));</pre>
<pre>
 print &quot;$x $y $i $o\n&quot;;</pre>
<pre>
 # $x $y $i 1</pre>
<p>
</p>
<h3><a name="constructing_expressions_with_big_integers">Constructing Expressions with Big Integers</a></h3>
<p>If you wish to use Math::Algebra::Symbols constructed with big integers from <a href="/Math/BigInt.html">the Math::BigInt manpage</a>:</p>
<pre>
 use Math::Algebra::Symbols BigInt=&gt;1;</pre>
<pre>
 my $z = symbols('1234567890987654321/1234567890987654321');</pre>
<pre>
 print &quot;$z\n&quot;;</pre>
<pre>
 # 1</pre>
<p>
</p>
<h2><a name="operators">Operators</a></h2>
<p><a href="#symbols">Symbols</a> can be combined with <a href="#operators">Operators</a> to create symbolic expressions:</p>
<p>
</p>
<h3><a name="arithmetic_operators">Arithmetic operators</a></h3>
<p>
</p>
<h4><a name="arithmetic_operators:_+__*_/_**">Arithmetic Operators: <strong>+</strong> <strong>-</strong> <strong>*</strong> <strong>/</strong> <strong>**</strong></a></h4>
<pre>

 use Math::Algebra::Symbols;</pre>
<pre>
 ($x, $y) = symbols(qw(x y));</pre>
<pre>
 $z = ($x**2-$y**2)/($x-$y);</pre>
<pre>
 print &quot;$z\n&quot;;</pre>
<pre>
 # $x+$y</pre>
<p>The auto assign versions of these operators: <strong>+=</strong> <strong>-=</strong> <strong>*=</strong> <strong>/=</strong> all
work courtesy of Perl Auto-Magical Operator Generation.</p>
<p>
</p>
<h4><a name="square_root_operator:_sqrt">Square root Operator: <strong>sqrt</strong></a></h4>
<pre>
 use Math::Algebra::Symbols;</pre>
<pre>
 $x = symbols(qw(x));</pre>
<pre>
 $z = sqrt(-$x**2);</pre>
<pre>
 print &quot;$z\n&quot;;</pre>
<pre>
 # $i*$x</pre>
<p>
</p>
<h4><a name="exponential_operator:_exp">Exponential Operator: <strong>exp</strong></a></h4>
<pre>
 use Math::Algebra::Symbols;</pre>
<pre>
 $x = symbols(qw(x));</pre>
<pre>
 $z = exp($x)-&gt;d($x);</pre>
<pre>
 print &quot;$z\n&quot;;</pre>
<pre>
 # exp($x)</pre>
<p>
</p>
<h4><a name="logarithm_operator:_log">Logarithm Operator: <strong>log</strong></a></h4>
<pre>
 use Math::Algebra::Symbols;</pre>
<pre>
 $x = symbols(qw(x));</pre>
<pre>
 $z = log(exp($x)*exp($x));</pre>
<pre>
 print &quot;$z\n&quot;;</pre>
<pre>
 # 2*$x</pre>
<p>
</p>
<h4><a name="sine_and_cosine_operators:_sin_and_cos">Sine and Cosine Operators: <strong>sin</strong> and <strong>cos</strong></a></h4>
<pre>
 use Math::Algebra::Symbols;</pre>
<pre>
 $x = symbols(qw(x));</pre>
<pre>
 $z = sin($x)**2 + cos($x)**2;</pre>
<pre>
 print &quot;$z\n&quot;;</pre>
<pre>
 # 1</pre>
<p>
</p>
<h3><a name="relational_operators">Relational operators</a></h3>
<p>
</p>
<h4><a name="relational_operators:_==,_!=">Relational operators: <strong>==</strong>, <strong>!=</strong></a></h4>
<pre>
 use Math::Algebra::Symbols;</pre>
<pre>
 ($x, $y) = symbols(qw(x y));</pre>
<pre>
 $z = ($x**2-$y**2)/($x+$y) == $x - $y;</pre>
<pre>
 print &quot;$z\n&quot;;</pre>
<pre>
 # 1</pre>
<p>The relational equality operator <strong>==</strong> compares two symbolic expressions
and returns <code>TRUE(1)</code> or <code>FALSE(0)</code> accordingly. <strong>!=</strong> produces the opposite
result.</p>
<p>
</p>
<h4><a name="relational_operator:_eq">Relational operator: <strong>eq</strong></a></h4>
<pre>
 use Math::Algebra::Symbols;</pre>
<pre>
 ($x, $v, $t) = symbols(qw(x v t));</pre>
<pre>
 $z = ($v eq $x / $t)-&gt;solve(qw(x in terms of v t));</pre>
<pre>
 print &quot;x=$z\n&quot;;</pre>
<pre>
 # x=$v*$t</pre>
<p>The relational operator <strong>eq</strong> is a synonym for the minus <strong>-</strong> operator,
with the expectation that later on the <a href="#solving_equations">solve()</a>
function will be used to simplify and rearrange the equation. You may
prefer to use <strong>eq</strong> instead of <strong>-</strong> to enhace readability, ther si no
functional difference.</p>
<p>
</p>
<h3><a name="implication_operators">Implication operators</a></h3>
<p>
</p>
<h4><a name="solve_operator:_>">Solve operator: <strong>&gt;</strong></a></h4>
<pre>
 use Math::Algebra::Symbols;</pre>
<pre>
 ($x, $v, $t) = symbols(qw(x v t));</pre>
<pre>
 $z = ($v eq $x / $t) &gt; [qw(x in terms of v t)];</pre>
<pre>
 print &quot;x=$z\n&quot;;</pre>
<pre>
 # x=$v*$t</pre>
<p>The solve operator <strong>&gt;</strong> is a synonym for the <a href="#solving_equations">solve()</a> function.</p>
<p>The priority of <strong>&gt;</strong> is higher than that of <strong>eq</strong>, so the brackets
around the equation to be solved are necessary until Perl provides a
mechanism for adjusting operator priority (cf. Algol 68).</p>
<p>If the equation is in a single variable, the single variable
may be named after the <strong>&gt;</strong> operator without the use of [...]:</p>
<pre>
 use Math::Algebra::Symbols;</pre>
<pre>
 my $rabbit  = 10 + 5 * $t;
 my $fox     = 7 * $t * $t;
 my ($a, $b) = @{($rabbit eq $fox) &gt; $t};</pre>
<pre>
 print &quot;$a\n&quot;;</pre>
<pre>
 # 1/14*sqrt(305)+5/14</pre>
<p>If there are multiple solutions, (as in the case of polynomials), <strong>&gt;</strong>
returns an array of symbolic expressions containing the solutions.</p>
<p>This example was provided by Mike Schilli <a href="mailto:m@perlmeister.com.">m@perlmeister.com.</a></p>
<p>
</p>
<h3><a name="complex_operators">Complex operators</a></h3>
<p>
</p>
<h4><a name="complex_operators:_the_dot_operator:_^">Complex operators: the <strong>dot</strong> operator: <strong>^</strong></a></h4>
<pre>
 use Math::Algebra::Symbols;</pre>
<pre>
 ($a, $b, $i) = symbols(qw(a b i));</pre>
<pre>
 $z = ($a+$i*$b)^($a-$i*$b);</pre>
<pre>
 print &quot;$z\n&quot;;</pre>
<pre>
 # $a**2-$b**2</pre>
<p>Note the use of brackets.  The <strong>^</strong> operator has low priority.</p>
<p>The <strong>^</strong> operator treats its left hand and right hand arguments as
complex numbers, which in turn are regarded as two dimensional vectors
to which the vector dot product is applied.</p>
<p>
</p>
<h4><a name="complex_operators:_the_cross_operator:_x">Complex operators: the <strong>cross</strong> operator: <strong>x</strong></a></h4>
<pre>
 use Math::Algebra::Symbols;</pre>
<pre>
 ($x, $i) = symbols(qw(x i));</pre>
<pre>
 $z = $i*$x x $x;</pre>
<pre>
 print &quot;$z\n&quot;;</pre>
<pre>
 # $x**2</pre>
<p>The <strong>x</strong> operator treats its left hand and right hand arguments as
complex numbers, which in turn are regarded as two dimensional vectors
defining the sides of a parallelogram. The <strong>x</strong> operator returns the
area of this parallelogram.</p>
<p>Note the space before the <strong>x</strong>, otherwise Perl is unable to disambiguate
the expression correctly.</p>
<p>
</p>
<h4><a name="complex_operators:_the_conjugate_operator:_~">Complex operators: the <strong>conjugate</strong> operator: <strong>~</strong></a></h4>
<pre>
 use Math::Algebra::Symbols;</pre>
<pre>
 ($x, $y, $i) = symbols(qw(x y i));</pre>
<pre>
 $z = $x+$i*$y;</pre>
<pre>
 print ~$z, &quot;\n&quot;;</pre>
<pre>
 # $x-$i*$y</pre>
<p>The <strong>~</strong> operator returns the complex conjugate of its right hand side.</p>
<p>
</p>
<h4><a name="complex_operators:_the_modulus_operator:_abs">Complex operators: the <strong>modulus</strong> operator: <strong>abs</strong></a></h4>
<pre>
 use Math::Algebra::Symbols;</pre>
<pre>
 ($x, $i) = symbols(qw(x i));</pre>
<pre>
 $z = abs($x+$i*$x);</pre>
<pre>
 print &quot;$z\n&quot;;</pre>
<pre>
 # sqrt(2)*$x</pre>
<p>The <strong>abs</strong> operator returns the modulus (length) of its right hand side.</p>
<p>
</p>
<h4><a name="complex_operators:_the_unit_operator:_!">Complex operators: the <strong>unit</strong> operator: <strong>!</strong></a></h4>
<pre>
 use Math::Algebra::Symbols;</pre>
<pre>
 $i = symbols(qw(i));</pre>
<pre>
 $z = !($i+1);</pre>
<pre>
 print &quot;$z\n&quot;;</pre>
<pre>
 # $i*sqrt(1/2)+sqrt(1/2)</pre>
<p>The <strong>!</strong> operator returns a complex number of unit length pointing in
the same direction as its right hand side.</p>
<p>
</p>
<h2><a name="functions">Functions</a></h2>
<p>Perl operator overloading is very useful for producing compact
representations of algebraic expressions. Unfortunately there are only a
small number of operators that Perl allows to be overloaded. The
following functions are used to provide capabilities not easily expressed
via Perl operator overloading.</p>
<p>These functions may either be called as methods from symbols constructed
by the <a href="#symbols">Symbols</a> construction routine, or they may be exported into
the user's namespace as described in <a href="#export">EXPORT</a>.</p>
<p>
</p>
<h3><a name="trigonometric_and_hyperbolic_functions">Trigonometric and Hyperbolic functions</a></h3>
<p>
</p>
<h4><a name="trigonometric_functions">Trigonometric functions</a></h4>
<pre>
 use Math::Algebra::Symbols trig=&gt;1;</pre>
<pre>
 ($x, $y) = symbols(qw(x y));</pre>
<pre>
 $z = sin($x)**2 == (1-cos(2*$x))/2;</pre>
<pre>
 print &quot;$z\n&quot;;</pre>
<pre>
 # 1</pre>
<p>The trigonometric functions <strong>cos</strong>, <strong>sin</strong>, <strong>tan</strong>, <strong>sec</strong>, <strong>csc</strong>,
<strong>cot</strong> are available, either as exports to the caller's name space, or
as methods.</p>
<p>
</p>
<h4><a name="hyperbolic_functions">Hyperbolic functions</a></h4>
<pre>
 use Math::Algebra::Symbols hyper=&gt;1;</pre>
<pre>
 ($x, $y) = symbols(qw(x y));</pre>
<pre>
 $z = tanh($x+$y)==(tanh($x)+tanh($y))/(1+tanh($x)*tanh($y));</pre>
<pre>
 print &quot;$z\n&quot;;</pre>
<pre>
 # 1</pre>
<p>The hyperbolic functions <strong>cosh</strong>, <strong>sinh</strong>, <strong>tanh</strong>, <strong>sech</strong>, <strong>csch</strong>,
<strong>coth</strong> are available, either as exports to the caller's name space, or
as methods.</p>
<p>
</p>
<h3><a name="complex_functions">Complex functions</a></h3>
<p>
</p>
<h4><a name="complex_functions:_re_and_im">Complex functions: <strong>re</strong> and <strong>im</strong></a></h4>
<pre>
 use Math::Algebra::Symbols complex=&gt;1;</pre>
<pre>
 ($x, $i) = symbols(qw(x i));</pre>
<pre>
 $R = re($i*$x);
 $I = im($i*$x);</pre>
<pre>
 print &quot;$R $I\n&quot;;</pre>
<pre>
 # 0 $x</pre>
<p>The <strong>re</strong> and <strong>im</strong> functions return an expression which represents the
real and imaginary parts of the expression, assuming that symbolic
variables represent real numbers.</p>
<p>
</p>
<h4><a name="complex_functions:_dot_and_cross">Complex functions: <strong>dot</strong> and <strong>cross</strong></a></h4>
<pre>
 use Math::Algebra::Symbols complex=&gt;1;</pre>
<pre>
 $i = symbols(qw(i));</pre>
<pre>
 $c = cross($i+1, $i-1);
 $d = dot  ($i+1, $i-1);</pre>
<pre>
 print &quot;$c $d\n&quot;;</pre>
<pre>
 # 2 0</pre>
<p>The <strong>dot</strong> and <strong>cross</strong> operators are available as functions, either as
exports to the caller's name space, or as methods.</p>
<p>
</p>
<h4><a name="complex_functions:_conjugate,_modulus_and_unit">Complex functions: <strong>conjugate</strong>, <strong>modulus</strong> and <strong>unit</strong></a></h4>
<pre>
 use Math::Algebra::Symbols complex=&gt;1;</pre>
<pre>
 $i = symbols(qw(i));</pre>
<pre>
 $x = unit($i+1);
 $y = modulus($i+1);
 $z = conjugate($i+1);</pre>
<pre>
 print &quot;$x\n$y\n$z\n&quot;;</pre>
<pre>
 # $i*sqrt(1/2)+sqrt(1/2)
 # sqrt(2)
 # 1-$i</pre>
<p>The <strong>conjugate</strong>, <strong>abs</strong> and <strong>unit</strong> operators are available as
functions: <strong>conjugate</strong>, <strong>modulus</strong> and <strong>unit</strong>, either as exports to
the caller's name space, or as methods. The confusion over the naming of:
the <strong>abs</strong> operator being the same as the <strong>modulus</strong> complex function;
arises over the limited set of Perl operator names available for
overloading.</p>
<p>
</p>
<h2><a name="methods">Methods</a></h2>
<p>
</p>
<h3><a name="methods_for_manipulating_equations">Methods for manipulating Equations</a></h3>
<p>
</p>
<h4><a name="simplifying_equations:_sub()">Simplifying equations: <strong>sub()</strong></a></h4>
<pre>
 use Math::Algebra::Symbols;
 
 ($x, $y) = symbols(qw(x y));
 
 $e  = 1+$x+$x**2/2+$x**3/6+$x**4/24+$x**5/120;</pre>
<pre>
 $e2 = $e-&gt;sub(x=&gt;$y**2, z=&gt;2);   #1
 $e3 = $e-&gt;sub(x=&gt;1);             #2</pre>
<pre>
 print &quot;$e2\n\n$e3\n\n&quot;;</pre>
<pre>
 # 1+$y**2+1/2*$y**4+1/6*$y**6+1/24*$y**8+1/120*$y**10</pre>
<pre>
 # 163/60</pre>
<p>The <strong>sub()</strong> function example on line <strong>#1</strong> demonstrates replacing
variables with expressions. The replacement specified for <strong>z</strong> has no
effect as <strong>z</strong> is not present in this equation.</p>
<p>Line <strong>#2</strong> demonstrates the resulting rational fraction that arises when
all the variables have been replaced by constants. This package does not
convert fractions to decimal expressions in case there is a loss of
acuracy, however:</p>
<pre>
 $e3 =~ /^(\d+)\/(\d+)$/;
 $result = $1/$2;</pre>
<p>or similar will produce approximate results.</p>
<p>
</p>
<h4><a name="solving_equations:_solve()">Solving equations: <strong>solve()</strong></a></h4>
<pre>
 use Math::Algebra::Symbols;</pre>
<pre>
 ($x, $v, $t) = symbols(qw(x v t));</pre>
<pre>
 $z = ($v eq $x / $t)-&gt;solve(qw(x in terms of v t)); #1</pre>
<pre>
 print &quot;x=$z\n&quot;;</pre>
<pre>
 # x=$v*$t</pre>
<p><strong>solve()</strong> assumes that the equation on the left hand side is equal to
zero, applies various simplifications, then attempts to rearrange the
equation to obtain an equation for the first variable in the parameter
list assuming that the other terms mentioned in the parameter list are
known constants. There may of course be other unknown free variables in
the equation to be solved: the proposed solution is automatically tested
against the original equation to check that the proposed solution
removes these variables, an error is reported via <strong>die()</strong> if it does not.</p>
<pre>
 use Math::Algebra::Symbols;
 use symbols;</pre>
<pre>
 my ($x) = symbols(qw(x));</pre>
<pre>
 my  $p = $x**2-5*$x+6;        # Quadratic polynomial
 my ($a, $b) = @{($p &gt; $x )};  # Solve for x</pre>
<pre>
 print &quot;x=$a,$b\n&quot;;            # Roots</pre>
<pre>
 # x=2,3</pre>
<p>If there are multiple solutions, (as in the case of polynomials), <strong>solve()</strong>
returns an array of symbolic expressions containing the solutions.</p>
<p>
</p>
<h3><a name="methods_for_performing_calculus">Methods for performing Calculus</a></h3>
<p>
</p>
<h4><a name="differentiation:_d()">Differentiation: <strong>d()</strong></a></h4>
<pre>
 use Math::Algebra::Symbols;</pre>
<pre>
 ($x, $i) = S(qw(x i));</pre>
<pre>
 $z = exp($x)-&gt;d-&gt;d('x')-&gt;d($x)-&gt;d();</pre>
<pre>
 print &quot;$z\n&quot;;</pre>
<pre>
 # exp($x)</pre>
<p><strong>d()</strong> differentiates the equation on the left hand side by the named
variable.</p>
<p>The variable to be differentiated by may be explicitly specifed,
either as a string or as single symbol; or it may be heuristically
guessed as follows:</p>
<p>If the equation to be differentiated refers to only one symbol, then
that symbol is used. If several symbols are present in the equation, but
only one of <strong>t</strong>, <strong>x</strong>, <strong>y</strong>, <strong>z</strong> is present, then that variable is
used in honor of Newton, Leibnitz, Cauchy.</p>
<p>
</p>
<h2><a name="examples">Examples</a></h2>
<p>
</p>
<h3><a name="example_expressions">Example Expressions</a></h3>
<pre>
 use Math::Algebra::Symbols;</pre>
<pre>
 ($a, $b, $x, $y, $i) = symbols(qw(a b x y i));</pre>
<pre>
   print $i x 1, &quot;\n&quot;;              # Cross product
 # 1</pre>
<pre>
   print $i^1,   &quot;\n&quot;;              # Dot product - different vectors
 # 0</pre>
<pre>
   print $i^$i,  &quot;\n&quot;;              # Dot product - same vector
 # 1</pre>
<pre>
   print abs $i, &quot;\n&quot;;              # Length of unit vector
 # 1</pre>
<pre>
   print ~($a+$b) == ~$a+~$b, &quot;\n&quot;; # Conjugation is distributive
 # 1                                  over addition</pre>
<pre>
   print ~($a*$b) == ~$a*~$b, &quot;\n&quot;; # Conjugation is distributive
 # 1                                  over multiplication</pre>
<pre>
   print ~($a**2) == (~$a)**2,&quot;\n&quot;; # Conjugation is distributive
 # 1                                  over power</pre>
<pre>
   print  abs(!($x+$y*$i))==1,&quot;\n&quot;; # Length of unit vector
 # 1</pre>
<pre>
   print                            # Length of product = product of lengths
         abs($a+$i*$b)*abs($x+$i*$y) ==
        abs(($a+$i*$b)*   ($x+$i*$y)), &quot;\n&quot;;
 # 1</pre>
<p>
</p>
<h3><a name="example_of_equation_solving:_the_focii_of_a_hyperbola:">Example of Equation Solving: the focii of a hyperbola:</a></h3>
<pre>
 use Math::Algebra::Symbols;
 ($a, $b, $x, $y, $i, $o) = symbols(qw(a b x y i 1));</pre>
<pre>
 print
 &quot;Hyperbola: Constant difference between distances from focii to locus of y=1/x&quot;,
 &quot;\n  Assume by symmetry the focii are on &quot;,
 &quot;\n    the line y=x:                     &quot;,  $f1 = $x + $i * $x,
 &quot;\n  and equidistant from the origin:    &quot;,  $f2 = -$f1,
 &quot;\n  Choose a convenient point on y=1/x: &quot;,  $a = $o+$i,
 &quot;\n        and a general point on y=1/x: &quot;,  $b = $y+$i/$y,
 &quot;\n  Difference in distances from focii&quot;,
 &quot;\n    From convenient point:            &quot;,  $A = abs($a - $f2) - abs($a - $f1),  
 &quot;\n    From general point:               &quot;,  $B = abs($b - $f2) + abs($b - $f1),
 &quot;\n\n  Solving for x we get:            x=&quot;, ($A - $B) &gt; $x,
 &quot;\n                         (should be: sqrt(2))&quot;,                        
 &quot;\n  Which is indeed constant, as was to be demonstrated\n&quot;;</pre>
<p>This example demonstrates the power of symbolic processing by finding the
focii of the curve <strong>y=1/x</strong>, and incidentally, demonstrating that this curve
is a hyperbola.</p>
<p>
</p>
<h3><a name="further_examples">Further Examples</a></h3>
<pre>
 use Math::Algebra::Symbols;</pre>
<pre>
 $x = symbols(qw(x));</pre>
<pre>
 $x-&gt;test();</pre>
<p>The <strong>test()</strong> method performs many tests which are useful in validating this package and as
examples of the capabilities of this package.  These tests may also be run as:</p>
<pre>
 perl symbols.pm</pre>
<p>
</p>
<hr />
<h1><a name="export">EXPORT</a></h1>
<pre>
 use Math::Algebra::Symbols
   symbols=&gt;'S',
   BigInt =&gt; 0,
   trig   =&gt; 1,
   hyper  =&gt; 1,
   complex=&gt; 1;</pre>
<dl>
<dt><strong><a name="item_bigint%3d%3e0">BigInt=&gt;0</a></strong><br />
</dt>
<dd>
The default - use regular perl numbers.
</dd>
<p></p>
<dt><strong><a name="item_bigint%3d%3e1">BigInt=&gt;1</a></strong><br />
</dt>
<dd>
Use Perl <a href="/Math/BigInt.html">the Math::BigInt manpage</a> to represent numbers.
</dd>
<p></p>
<dt><strong><a name="item_symbols%3d%3e%27name%27">symbols=&gt;'name'</a></strong><br />
</dt>
<dd>
Create a routine with this name in the caller's namespace to construct
new symbols. The default is <strong>symbols</strong>.
</dd>
<p></p>
<dt><strong><a name="item_trig%3d%3e0">trig=&gt;0</a></strong><br />
</dt>
<dd>
The default, do not export trigonometric functions.
</dd>
<p></p>
<dt><strong><a name="item_trig%3d%3e1">trig=&gt;1</a></strong><br />
</dt>
<dd>
Export trigonometric functions: <strong>tan</strong>, <strong>sec</strong>, <strong>csc</strong>, <strong>cot</strong> to the
caller's namespace. <strong>sin</strong>, <strong>cos</strong> are created by default by overloading
the existing Perl <strong>sin</strong> and <strong>cos</strong> operators.
</dd>
<p></p>
<dt><strong><a name="item_trigonometric"><strong>trigonometric</strong></a></strong><br />
</dt>
<dd>
Alias of <strong>trig</strong>
</dd>
<p></p>
<dt><strong><a name="item_hyperbolic%3d%3e0">hyperbolic=&gt;0</a></strong><br />
</dt>
<dd>
The default, do not export hyperbolic functions.
</dd>
<p></p>
<dt><strong><a name="item_hyper%3d%3e1">hyper=&gt;1</a></strong><br />
</dt>
<dd>
Export hyperbolic functions: <strong>sinh</strong>, <strong>cosh</strong>, <strong>tanh</strong>, <strong>sech</strong>,
<strong>csch</strong>, <strong>coth</strong> to the caller's namespace.
</dd>
<p></p>
<dt><strong><a name="item_hyperbolic"><strong>hyperbolic</strong></a></strong><br />
</dt>
<dd>
Alias of <strong>hyper</strong>
</dd>
<p></p>
<dt><strong><a name="item_complex%3d%3e0">complex=&gt;0</a></strong><br />
</dt>
<dd>
The default, do not export complex functions
</dd>
<p></p>
<dt><strong><a name="item_complex%3d%3e1">complex=&gt;1</a></strong><br />
</dt>
<dd>
Export complex functions: <strong>conjugate</strong>, <strong>cross</strong>, <strong>dot</strong>, <strong>im</strong>,
<strong>modulus</strong>, <strong>re</strong>, <strong>unit</strong> to the caller's namespace.
</dd>
<p></p></dl>
<p>
</p>
<hr />
<h1><a name="packages">PACKAGES</a></h1>
<p>The Symbols packages manipulate a sum of products representation of an
algebraic equation. The <strong>Symbols</strong> package is the user interface to the
functionality supplied by the <strong>SymbolsSum</strong> and <strong>SymbolsTerm</strong> packages.</p>
<p>
</p>
<h2><a name="math::algebra::symbolsterm">Math::Algebra::SymbolsTerm</a></h2>
<p><strong>SymbolsTerm</strong> represents a product term. A product term consists of the
number <strong>1</strong>, optionally multiplied by:</p>
<dl>
<dt><strong><a name="item_variables">Variables</a></strong><br />
</dt>
<dd>
any number of variables raised to integer powers,
</dd>
<p></p>
<dt><strong><a name="item_coefficient">Coefficient</a></strong><br />
</dt>
<dd>
An integer coefficient optionally divided by a positive integer divisor,
both represented as BigInts if necessary.
</dd>
<p></p>
<dt><strong><a name="item_sqrt">Sqrt</a></strong><br />
</dt>
<dd>
The sqrt of of any symbolic expression representable by the <strong>Symbols</strong>
package, including minus one: represented as <strong>i</strong>.
</dd>
<p></p>
<dt><strong><a name="item_reciprocal">Reciprocal</a></strong><br />
</dt>
<dd>
The multiplicative inverse of any symbolic expression representable by
the <strong>Symbols</strong> package: i.e. a <strong>SymbolsTerm</strong> may be divided by any
symbolic expression representable by the <strong>Symbols</strong> package.
</dd>
<p></p>
<dt><strong><a name="item_exp">Exp</a></strong><br />
</dt>
<dd>
The number <strong>e</strong> raised to the power of any symbolic expression
representable by the <strong>Symbols</strong> package.
</dd>
<p></p>
<dt><strong><a name="item_log">Log</a></strong><br />
</dt>
<dd>
The logarithm to base <strong>e</strong> of any symbolic expression representable by
the <strong>Symbols</strong> package.
</dd>
<p></p></dl>
<p>Thus <strong>SymbolsTerm</strong> can represent expressions like:</p>
<pre>
  2/3*x**2*y**-3*exp(i*pi)*sqrt(z**3) / x</pre>
<p>but not:</p>
<pre>
  x + y</pre>
<p>for which package <strong>SymbolsSum</strong> is required.</p>
<p>
</p>
<h2><a name="math::algebra::symbolssum">Math::Algebra::SymbolsSum</a></h2>
<p><strong>SymbolsSum</strong> represents a sum of product terms supplied by
<strong>SymbolsTerm</strong> and thus behaves as a polynomial. Operations such as
equation solving and differentiation are applied at this level.</p>
<p>The main benefit of programming <strong>SymbolsTerm</strong> and <strong>SymbolsSum</strong> as two
separate but related packages is Object Oriented Polymorphism. I.e. both
packages need to multiply items together: each package has its own <strong>multiply</strong> method,
with Perl method lookup selecting the appropriate one as required.</p>
<p>
</p>
<h2><a name="math::algebra::symbols">Math::Algebra::Symbols</a></h2>
<p>Packaging the user functionality alone and separately in package
<strong>Symbols</strong> allows the internal functions to be conveniently hidden from
user scripts.</p>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<p>Philip R Brenan at <strong><a href="mailto:philiprbrenan@yahoo.com">philiprbrenan@yahoo.com</a></strong></p>

</body>

</html>
